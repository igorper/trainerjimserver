var dashboard = angular.module('dashboard', [
  'ui.router',
  'results',
  'nvd3',
  'util.promiseUi'
]);

dashboard.config(['$stateProvider', function ($stateProvider) {
  $stateProvider.state('main.dashboard', {
    url: '/dashboard',
    abstract: true,
    templateUrl: "<%= asset_path('dashboard/dashboard.html') %>",
    controller: ['$scope', 'Trainee', '$state', 'toaster', function ($scope, Trainee, $state, toaster) {
      $scope.state = $state;

      $scope.users = Trainee.query(function () {
      }, function () {
        toaster.pop("error", "Trainees listing", "Could get the list of trainees. Try logging in again.");
      });

      $scope.getCurrentUserId = function () {
        return $state.params.id == "" ? null : parseInt($state.params.id);
      };

      $scope.onUserSelected = function (user) {
        $state.go('main.dashboard.user', {id: user === undefined ? '' : user.id});
      };
    }]
  });

  $stateProvider.state('main.dashboard.user', {
    url: '/:id',
    templateUrl: "<%= asset_path('dashboard/dashboard-user.html') %>",
    controller: ['$scope', 'Measurement', '$state', 'toaster', 'ExerciseGroup', '$q', 'DashboardStats', function ($scope, Measurement, $state, toaster, ExerciseGroup, promise, DashboardStats) {
      $scope.sortType = "date";
      $scope.sortReverse = false;
      $scope.periodName = "all";

      $scope.overviewCalculationPromise = promise
        .all({measurements: fetchMeasurements(), exerciseGroups: ExerciseGroup.query().$promise})
        .catch(overviewCalculationFailed)
        .then(function (fetchedData) {
          $scope.dashboardStats = new DashboardStats(fetchedData.measurements, fetchedData.exerciseGroups);
        });


      function fetchMeasurements() {
        if ($state.params.id === "") {
          return Measurement.detailedMeasurements().$promise;
        } else {
          return Measurement.detailedMeasurementsForUser({userId: $state.params.id}).$promise;
        }
      }

      function overviewCalculationFailed() {
        toaster.pop("error", "Error while fetching measurements", "Unable to fetch measurements. An unexpected error occurred.");
      }


      $scope.goToResults = function (measurement) {
        console.log("Going to:", measurement);
        $state.go('main.results', {trainee: measurement.trainee_id, id: measurement.id});
      };

      $scope.allUsersSelected = function () {
        return $state.params.id === "";
      };

      $scope.executedExerciseGroupsPieChartOptions = {
        chart: {
          type: 'pieChart',
          x: function (d) {
            return d.exerciseGroup.name;
          },
          y: function (d) {
            return d.count;
          },
          showLabels: true,
          transitionDuration: 500,
          height: 300
        }
      };
    }]
  });
}]);


dashboard.filter('withinPeriodFilter', function () {
  function daysInPeriod(periodName) {
    switch (periodName) {
      case 'day':
        return 1;
      case 'week':
        return 7;
      case 'month':
        return 30;
      default:
        return undefined;
    }
  }

  function withinDaysFilter(items, days) {
    var from = new Date();
    from.setDate(from.getDate() - days);
    return _.filter(items, function (item) {
      return new Date(item.date) > from;
    });
  }

  return function (items, periodName) {
    var days = daysInPeriod(periodName);
    return _.isUndefined(days) ? items : withinDaysFilter(items, days);
  };
});

function toLookupById(itemsWithIds) {
  return _.reduce(itemsWithIds, function (lookupById, item) {
    lookupById[item.id] = item;
    return lookupById;
  }, {});
}

dashboard.factory('MeasurementStats', [function () {
  var TOO_HARD_RATING = 0;
  var OKAY_RATING = 1;
  var TOO_EASY_RATING = 2;

  function MeasurementStats(measurement) {
    this.measurement = measurement;
    var training = measurement.training;
    this.seriesLookup = toLookupById(_.chain(training.exercises).pluck('series').flatten().value());
    this.name = training.name;
    this.date = measurement.start_time;
    this.comment = measurement.comment;
    this.totalSeries = countSeriesInTraining(training);
    this.performedSeries = measurement.series_executions.length;
    this.seriesSkipped = this.totalSeries - this.performedSeries;
    this.restTimeChangeInSeconds = restTimeChangeInSeconds(measurement.series_executions, this.seriesLookup);
    this.seriesTooHardCount = _.chain(measurement.series_executions).where({rating: TOO_HARD_RATING}).size().value();
    this.seriesTooEasyCount = _.chain(measurement.series_executions).where({rating: TOO_EASY_RATING}).size().value();
    this.seriesOkayCount = _.chain(measurement.series_executions).where({rating: OKAY_RATING}).size().value();
  }

  function countSeriesInTraining(training) {
    return _.reduce(training.exercises, function (count, exercise) {
      return count + _.size(exercise.series);
    }, 0);
  }

  function restTimeChangeInSeconds(seriesExecutions, seriesLookup) {
    return _.reduce(seriesExecutions, function (change, se) {
      return change + se.rest_time - seriesLookup[se.series_id].rest_time;
    }, 0);
  }

  return MeasurementStats;
}]);

dashboard.factory('DashboardStats', ['MeasurementStats', function (MeasurementStats) {
  function DashboardStats(measurements, exerciseGroups) {
    this.executedExerciseGroupsCounts = countExecutedExerciseGroups(measurements);
    this.exerciseGroupsLookup = toLookupById(exerciseGroups);
    this.partitionedGroupCounts = partitionExerciseGroupCounts(this.exerciseGroupsLookup, this.executedExerciseGroupsCounts);
    this.muscleGroupCounts = this.partitionedGroupCounts[0];
    this.equipmentGroupCounts = this.partitionedGroupCounts[1];
    this.measurementsStats = _.map(measurements, function (measurement) {
      return new MeasurementStats(measurement);
    });
  }

  /**
   * @param measurements the measurement in which to count executed exercise groups.
   * @return a lookup object from exercise groups to the number of times they appeared in executed series
   * in the given measurements.
   */
  function countExecutedExerciseGroups(measurements) {
    var seriesToExerciseGroups = extractSeriesToExerciseGroupIdsLookup(measurements);
    var exerciseGroupCounts = {};
    _.each(measurements, function (measurement) {
      _.each(measurement.series_executions, function (seriesExecution) {
        _.each(seriesToExerciseGroups[seriesExecution.series_id], function (groupId) {
          exerciseGroupCounts[groupId] = 1 + (exerciseGroupCounts[groupId] || 0);
        });
      });
    });
    return exerciseGroupCounts;
  }

  /**
   * @return {*} a lookup object of series IDs to lists of group IDs to which these series belong.
   */
  function extractSeriesToExerciseGroupIdsLookup(measurements) {
    var seriesToExerciseGroups = {};
    _.each(measurements, function (measurement) {
      _.each(measurement.training.exercises, function (exercise) {
        _.each(exercise.series, function (serie) {
          seriesToExerciseGroups[serie.id] = _.union(exercise.exercise_type.exercise_groups, seriesToExerciseGroups[serie.id]);
        });
      });
    });
    return seriesToExerciseGroups;
  }

  function partitionExerciseGroupCounts(exerciseGroupsLookup, exerciseGroupCounters) {
    return _.chain(exerciseGroupCounters)
      .map(function (count, exerciseGroupId) {
        return {exerciseGroup: exerciseGroupsLookup[exerciseGroupId], count: count};
      })
      .partition(function (exerciseGroupAndCount) {
        return exerciseGroupAndCount.exerciseGroup.is_machine_group;
      })
      .value();
  }

  return DashboardStats;
}]);