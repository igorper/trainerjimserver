var dashboard = angular.module('dashboard', [
  'ui.router',
  'results',
  'nvd3',
  'util.promiseUi'
]);

dashboard.config(['$stateProvider', function ($stateProvider) {
  $stateProvider.state('main.dashboard', {
    url: '/dashboard',
    abstract: true,
    templateUrl: "<%= asset_path('dashboard/dashboard.html') %>",
    controller: ['$scope', 'Trainee', '$state', 'toaster', function ($scope, Trainee, $state, toaster) {
      $scope.state = $state;

      $scope.users = Trainee.query(function () {
      }, function () {
        toaster.pop("error", "Trainees listing", "Could get the list of trainees. Try logging in again.");
      });

      $scope.getCurrentUserId = function () {
        return $state.params.id == "" ? null : parseInt($state.params.id);
      };

      $scope.onUserSelected = function (user) {
        $state.go('main.dashboard.user', {id: user === undefined ? '' : user.id});
      };
    }]
  });

  $stateProvider.state('main.dashboard.user', {
    url: '/:id',
    templateUrl: "<%= asset_path('dashboard/dashboard-user.html') %>",
    controller: ['$scope', 'Measurement', '$state', 'toaster', 'resultsUtil', 'ExerciseGroup', '$q', function ($scope, Measurement,
                                                                                                               $state, toaster, resultsUtil, ExerciseGroup, promise) {
      $scope.items = [];

      $scope.sortType = "date";
      $scope.sortReverse = false;
      $scope.dateFilter = "all";

      $scope.overviewCalculationPromise = promise
        .all({measurements: fetchMeasurements(), exerciseGroups: fetchExerciseGroups()})
        .then(calculateMeasurementsOverview)
        .catch(overviewCalculationFailed);

      $scope.muscleGroups = [];
      $scope.equipmentGroups = [];

      function fetchMeasurements() {
        if ($state.params.id === "") {
          return Measurement.query().$promise;
        } else {
          return Measurement.queryForUser({userId: $state.params.id}).$promise;
        }
      }

      function fetchExerciseGroups() {
        return ExerciseGroup.query().$promise;
      }

      function calculateMeasurementsOverview(allData) {
        return promise.all(_.map(allData.measurements, function (measurement) {
          return calculateMeasurementOverview(measurement.id, allData.exerciseGroups);
        }));
      }

      function overviewCalculationFailed() {
        toaster.pop("error", "Error while fetching measurements", "Unable to fetch measurements. An unexpected error occurred.");
      }

      function calculateMeasurementOverview(measurementId, exerciseGroups) {
        return Measurement.get({id: measurementId}).$promise.then(function (measurementDetails) {
          addMeasurementOverview(measurementDetails, exerciseGroups);
        });
      }

      $scope.exerciseGroupIdsToCount = {};

      function addMeasurementOverview(measurement, exerciseGroups) {
        var overview = resultsUtil.calculateResultsOverview(measurement, exerciseGroups);
        var idsToExerciseGroups = toExerciseGroupLookupById(exerciseGroups);
        var seriesToExerciseGroups = extractSeriesToExerciseGroupsMap(measurement.training.exercises);
        countExerciseGroups(measurement, seriesToExerciseGroups, $scope.exerciseGroupIdsToCount);
        var groupCounts = _.partition(toGroupAndCounts(idsToExerciseGroups), function (exerciseGroupAndCount) {
          return exerciseGroupAndCount.exerciseGroup.is_machine_group;
        });
        $scope.muscleGroups = groupCounts[0];
        $scope.equipmentGroups = groupCounts[1];

        $scope.items.push(overview);
      }

      /**
       * @return {*} an object of the form `{exerciseGroup, count}`.
       */
      function toGroupAndCounts(exerciseGroupsLookupById) {
        return _.map($scope.exerciseGroupIdsToCount, function (count, exerciseGroupId) {
          return {exerciseGroup: exerciseGroupsLookupById[exerciseGroupId], count: count};
        });
      }

      /**
       * @return {*} an object with exercise group IDs as keys and exercise groups themselves as values.
       */
      function toExerciseGroupLookupById(exerciseGroups) {
        return _.object(_.map(exerciseGroups, function (exerciseGroup) {
          return [exerciseGroup.id, exerciseGroup];
        }));
      }

      /**
       * @param measurement the measurement from which to count executed exercise  groups.
       * @param seriesToExerciseGroup a lookup object of series IDs as keys and exercise groups as values.
       * @param outputExerciseGroupToCount an object with exercise group IDs as keys and counts as values. This
       * object will be updated with counts.
       * @return an object with exercise group IDs as keys and counts as values.
       */
      function countExerciseGroups(measurement, seriesToExerciseGroup, outputExerciseGroupToCount) {
        return _.reduce(measurement.series_executions, function (exerciseGroupCounts, seriesExecution) {
          _.each(seriesToExerciseGroup[seriesExecution.series_id], function (groupId) {
            exerciseGroupCounts[groupId] = 1 + (exerciseGroupCounts[groupId] || 0);
          });
          return exerciseGroupCounts;
        }, outputExerciseGroupToCount);
      }

      /**
       * @return {*} an object with series IDs as keys and lists of groups to which these series belong as
       * values.
       */
      function extractSeriesToExerciseGroupsMap(exercises) {
        return _.reduce(exercises, function (seriesToExerciseGroups, exercise) {
          _.each(exercise.series, function (serie) {
            seriesToExerciseGroups[serie.id] = _.union(exercise.exercise_type.exercise_groups, seriesToExerciseGroups[serie.id]);
          });
          return seriesToExerciseGroups;
        }, {});
      }


      $scope.goToMeasurement = function (item) {
        $state.go('main.results', {trainee: $state.params.id, id: item.id});
      };

      $scope.allUsersSelected = function () {
        return $state.params.id === "";
      };

      $scope.options = {
        chart: {
          type: 'pieChart',
          x: function (d) {
            return d.exerciseGroup.name;
          },
          y: function (d) {
            return d.count;
          },
          showLabels: true,
          transitionDuration: 500,
          height: 300
        }
      };

      $scope.scatterOptions = {
        chart: {
          type: 'scatterChart',
          height: 450,
          color: d3.scale.category10().range(),
          scatter: {
            onlyCircles: false
          },
          showDistX: true,
          showDistY: true,
          tooltipContent: function (key) {
            return '<h3>' + key + '</h3>';
          },
          transitionDuration: 350,
          xAxis: {
            axisLabel: 'X Axis',
            tickFormat: function (d) {
              return d3.format('.02f')(d);
            }
          },
          yAxis: {
            axisLabel: 'Y Axis',
            tickFormat: function (d) {
              return d3.format('.02f')(d);
            },
            axisLabelDistance: 30
          }
        }
      };

      $scope.scatterData = generateData(4, 40);

      /* Random Data Generator (took from nvd3.org) */
      function generateData(groups, points) {
        var data = [],
          shapes = ['circle', 'cross', 'triangle-up', 'triangle-down', 'diamond', 'square'],
          random = d3.random.normal();

        for (var i = 0; i < groups; i++) {
          data.push({
            key: 'Group ' + i,
            values: []
          });

          for (var j = 0; j < points; j++) {
            data[i].values.push({
              x: random()
              , y: random()
              , size: Math.random()
              , shape: shapes[j % 6]
            });
          }
        }
        return data;
      }
    }]
  });
}]);


dashboard.filter('dateRangeFilter', function () {
  function daysInPeriod(periodName) {
    switch (periodName) {
      case 'day':
        return 1;
      case 'week':
        return 7;
      case 'month':
        return 30;
      default:
        return undefined;
    }
  }

  function withinDaysFilter(items, days) {
    var from = new Date();
    from.setDate(from.getDate() - days);
    return _.filter(items, function (item) {
      return new Date(item.date) > from;
    });
  }

  return function (items, periodName) {
    var days = daysInPeriod(periodName);
    return _.isUndefined(days) ? items : withinDaysFilter(items, days);
  };
});